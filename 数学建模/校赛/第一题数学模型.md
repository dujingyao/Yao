# LED显示屏颜色转换设计与校正 - 第一题数学模型

## 📐 问题描述与数学建模

### 问题定义
将BT2020视频源色域映射到标准显示器RGB色域，最小化颜色转换损失，同时确保所有颜色都在目标显示器的可显示范围内。

### 数学建模目标
建立从源色域 $\Gamma_{src}$ 到目标色域 $\Gamma_{dst}$ 的映射函数：
$$f: \Gamma_{src} \rightarrow \Gamma_{dst}$$
使得色差函数 $\Delta E(c_{src}, f(c_{src}))$ 最小化。

---

## 🔬 **核心算法体系**

### 🎯 **算法1：色彩空间转换算法**

#### **1.1 sRGB到线性RGB转换**
```math
\text{线性化函数：} \quad \gamma^{-1}(x) = \begin{cases}
\frac{x}{12.92} & \text{if } x \leq 0.04045 \\
\left(\frac{x + 0.055}{1.055}\right)^{2.4} & \text{if } x > 0.04045
\end{cases}
```

**应用**：
$$RGB_{linear} = \gamma^{-1}(RGB_{sRGB})$$

#### **1.2 线性RGB到sRGB转换**
```math
\text{伽马校正函数：} \quad \gamma(x) = \begin{cases}
12.92 \cdot x & \text{if } x \leq 0.0031308 \\
1.055 \cdot x^{1/2.4} - 0.055 & \text{if } x > 0.0031308
\end{cases}
```

**应用**：
$$RGB_{sRGB} = \gamma(RGB_{linear})$$

#### **1.3 RGB到XYZ颜色空间转换**
**标准sRGB转换矩阵**：
$$\begin{bmatrix} X \\ Y \\ Z \end{bmatrix} = \begin{bmatrix}
0.4124564 & 0.3575761 & 0.1804375 \\
0.2126729 & 0.7151522 & 0.0721750 \\
0.0193339 & 0.1191920 & 0.9503041
\end{bmatrix} \begin{bmatrix} R_{linear} \\ G_{linear} \\ B_{linear} \end{bmatrix}$$

#### **1.4 XYZ到RGB颜色空间转换**
**逆转换矩阵**：
$$\begin{bmatrix} R_{linear} \\ G_{linear} \\ B_{linear} \end{bmatrix} = \begin{bmatrix}
3.2404542 & -1.5371385 & -0.4985314 \\
-0.9692660 & 1.8760108 & 0.0415560 \\
0.0556434 & -0.2040259 & 1.0572252
\end{bmatrix} \begin{bmatrix} X \\ Y \\ Z \end{bmatrix}$$

#### **1.5 XYZ到CIE xy色度坐标转换**
$$x = \frac{X}{X + Y + Z}, \quad y = \frac{Y}{X + Y + Z}$$

**边界条件处理**：
$$\text{当 } X + Y + Z = 0 \text{ 时，设置为 } 10^{-10} \text{ 避免除零}$$

#### **1.6 xy到XYZ转换（给定亮度Y）**
$$X = Y \cdot \frac{x}{y}, \quad Z = Y \cdot \frac{1-x-y}{y}$$

**边界条件**：
$$\text{当 } y = 0 \text{ 时，设置 } y = 10^{-10}$$

---

### 🎨 **算法2：CIE Lab颜色空间转换**

#### **2.1 XYZ到Lab转换**
**标准化到D65白点**：
$$X_n = 0.95047, \quad Y_n = 1.00000, \quad Z_n = 1.08883$$
$$\tilde{X} = \frac{X}{X_n}, \quad \tilde{Y} = \frac{Y}{Y_n}, \quad \tilde{Z} = \frac{Z}{Z_n}$$

**非线性变换函数**：
$$f(t) = \begin{cases}
t^{1/3} & \text{if } t > \delta^3 \\
\frac{t}{3\delta^2} + \frac{4}{29} & \text{if } t \leq \delta^3
\end{cases}$$
其中 $\delta = \frac{6}{29}$

**Lab坐标计算**：
$$L^* = 116 \cdot f(\tilde{Y}) - 16$$
$$a^* = 500 \cdot (f(\tilde{X}) - f(\tilde{Y}))$$
$$b^* = 200 \cdot (f(\tilde{Y}) - f(\tilde{Z}))$$

#### **2.2 CIE ΔE*ab色差计算**
**欧几里得距离公式**：
$$\Delta E_{ab}^* = \sqrt{(\Delta L^*)^2 + (\Delta a^*)^2 + (\Delta b^*)^2}$$

其中：
$$\Delta L^* = L_1^* - L_2^*, \quad \Delta a^* = a_1^* - a_2^*, \quad \Delta b^* = b_1^* - b_2^*$$

---

### 🔺 **算法3：几何色域检测**

#### **3.1 点在三角形内判断算法（重心坐标法）**
给定三角形顶点 $P_0, P_1, P_2$ 和测试点 $P$：

**向量定义**：
$$\vec{v_0} = P_2 - P_0, \quad \vec{v_1} = P_1 - P_0, \quad \vec{v_2} = P - P_0$$

**点积计算**：
$$dot_{00} = \vec{v_0} \cdot \vec{v_0}, \quad dot_{01} = \vec{v_0} \cdot \vec{v_1}$$
$$dot_{02} = \vec{v_0} \cdot \vec{v_2}, \quad dot_{11} = \vec{v_1} \cdot \vec{v_1}, \quad dot_{12} = \vec{v_1} \cdot \vec{v_2}$$

**重心坐标计算**：
$$invDenom = \frac{1}{dot_{00} \cdot dot_{11} - dot_{01}^2}$$
$$u = (dot_{11} \cdot dot_{02} - dot_{01} \cdot dot_{12}) \cdot invDenom$$
$$v = (dot_{00} \cdot dot_{12} - dot_{01} \cdot dot_{02}) \cdot invDenom$$

**判断条件**：
$$\text{点在三角形内} \Leftrightarrow (u \geq 0) \land (v \geq 0) \land (u + v \leq 1)$$

#### **3.2 色域定义**
**BT2020色域顶点（CIE xy坐标）**：
$$V_{BT2020} = \begin{bmatrix}
0.708 & 0.292 \\  \text{(Red)}
0.170 & 0.797 \\  \text{(Green)}
0.131 & 0.046     \text{(Blue)}
\end{bmatrix}$$

**标准显示器色域顶点（sRGB）**：
$$V_{sRGB} = \begin{bmatrix}
0.640 & 0.330 \\  \text{(Red)}
0.300 & 0.600 \\  \text{(Green)}
0.150 & 0.060     \text{(Blue)}
\end{bmatrix}$$

---

### 📐 **算法4：智能色域映射**

#### **4.1 色域中心计算**
$$\text{中心点} = \frac{1}{3}(V_1 + V_2 + V_3) = \begin{bmatrix} \bar{x} \\ \bar{y} \end{bmatrix}$$

对于sRGB色域：
$$\text{Center}_{sRGB} = \begin{bmatrix} 0.363 \\ 0.330 \end{bmatrix}$$

#### **4.2 射线-线段交点算法**
给定射线起点 $O$，方向 $\vec{d}$，线段端点 $P_1, P_2$：

**参数方程**：
- 射线：$R(t) = O + t \cdot \vec{d}$
- 线段：$S(u) = P_1 + u \cdot (P_2 - P_1)$

**求解交点**：
$$\vec{edge} = P_2 - P_1$$
$$\vec{toP1} = P_1 - O$$

**2D叉积计算**：
$$cross_{ed} = d_x \cdot edge_y - d_y \cdot edge_x$$
$$t = \frac{toP1_x \cdot edge_y - toP1_y \cdot edge_x}{cross_{ed}}$$
$$u = \frac{toP1_x \cdot d_y - toP1_y \cdot d_x}{cross_{ed}}$$

**有效交点条件**：
$$(t > 0) \land (0 \leq u \leq 1) \land (|cross_{ed}| > \epsilon)$$

#### **4.3 自适应压缩策略**
**颜色特征提取**：
$$saturation = \max(R,G,B) - \min(R,G,B)$$
$$brightness = \frac{R + G + B}{3}$$

**压缩因子选择**：
$$compression\_factor = \begin{cases}
0.85 & \text{if } saturation > 0.8 \text{ (高饱和度)} \\
0.90 & \text{if } brightness < 0.3 \text{ (暗色调)} \\
0.88 & \text{otherwise (普通情况)}
\end{cases}$$

**压缩映射公式**：
$$P_{compressed} = P_{center} + compression\_factor \cdot (P_{intersection} - P_{center})$$

---

### 🎨 **算法5：HSV颜色空间处理**

#### **5.1 RGB到HSV转换**
**亮度值**：
$$V = \max(R, G, B)$$

**饱和度**：
$$S = \begin{cases}
0 & \text{if } V = 0 \\
\frac{V - \min(R,G,B)}{V} & \text{otherwise}
\end{cases}$$

**色相计算**：
$$\Delta = V - \min(R,G,B)$$
$$H = \begin{cases}
0 & \text{if } \Delta = 0 \\
60 \cdot \frac{G-B}{\Delta} & \text{if } V = R \\
60 \cdot (2 + \frac{B-R}{\Delta}) & \text{if } V = G \\
60 \cdot (4 + \frac{R-G}{\Delta}) & \text{if } V = B
\end{cases}$$

**归一化**：
$$H = (H + 360) \bmod 360$$

#### **5.2 HSV到RGB转换**
**中间变量**：
$$C = V \cdot S$$
$$X = C \cdot \left(1 - \left|\left(\frac{H}{60}\right) \bmod 2 - 1\right|\right)$$
$$m = V - C$$

**RGB分量计算**：
$$(R', G', B') = \begin{cases}
(C, X, 0) & \text{if } 0 \leq H < 60 \\
(X, C, 0) & \text{if } 60 \leq H < 120 \\
(0, C, X) & \text{if } 120 \leq H < 180 \\
(0, X, C) & \text{if } 180 \leq H < 240 \\
(X, 0, C) & \text{if } 240 \leq H < 300 \\
(C, 0, X) & \text{if } 300 \leq H < 360
\end{cases}$$

**最终结果**：
$$RGB = (R', G', B') + (m, m, m)$$

---

## 🔄 **完整算法流程**

### **主算法：增强色域映射**
```
输入：源RGB颜色 rgb_src
输出：映射RGB颜色 rgb_dst

1. 转换到xy色度坐标：
   xy_src = RGB_to_xy(rgb_src)

2. 色域检测：
   if point_in_triangle(xy_src, sRGB_vertices):
       return rgb_src  // 已在目标色域内
   
3. 智能压缩映射：
   center = gamut_center(sRGB_vertices)
   direction = normalize(xy_src - center)
   intersection = find_intersection(center, direction, sRGB_vertices)
   
4. 自适应压缩：
   compression = adaptive_compression_factor(rgb_src)
   xy_mapped = center + compression * (intersection - center)
   
5. 转换回RGB：
   Y = mean(rgb_src)  // 保持亮度
   rgb_dst = xy_to_RGB(xy_mapped, Y)
   
6. 边界裁剪：
   return clip(rgb_dst, 0, 1)
```

### **质量评估算法**
```
输入：源图像 img_src，映射图像 img_dst
输出：质量评估报告

1. 逐像素色差计算：
   for each pixel (i,j):
       lab_src = RGB_to_Lab(img_src[i,j])
       lab_dst = RGB_to_Lab(img_dst[i,j])
       delta_e[i,j] = CIE_delta_E(lab_src, lab_dst)

2. 统计分析：
   mean_de = mean(delta_e)
   median_de = median(delta_e)
   std_de = std(delta_e)
   max_de = max(delta_e)
   
3. 质量分级：
   excellent = count(delta_e < 1) / total_pixels
   good = count(1 ≤ delta_e < 3) / total_pixels
   acceptable = count(3 ≤ delta_e < 6) / total_pixels
   poor = count(6 ≤ delta_e < 10) / total_pixels
   very_poor = count(delta_e ≥ 10) / total_pixels
```

---

## 📊 **数学模型验证**

### **优化目标函数**
最小化总色差：
$$\min_{f} \sum_{i=1}^{N} \Delta E_{ab}^*(c_i, f(c_i))$$

约束条件：
$$f(c_i) \in \Gamma_{sRGB}, \quad \forall i \in \{1, 2, ..., N\}$$

### **性能指标**
1. **平均色差**：$\bar{\Delta E} = \frac{1}{N}\sum_{i=1}^{N} \Delta E_i$
2. **色差标准差**：$\sigma_{\Delta E} = \sqrt{\frac{1}{N}\sum_{i=1}^{N} (\Delta E_i - \bar{\Delta E})^2}$
3. **优秀率**：$R_{excellent} = \frac{|\{i: \Delta E_i < 1\}|}{N}$
4. **失真率**：$R_{distortion} = \frac{|\{i: \Delta E_i \geq 10\}|}{N}$

### **算法复杂度分析**
- **时间复杂度**：$O(N)$，其中N为像素数
- **空间复杂度**：$O(1)$，原地处理
- **数值稳定性**：所有除法操作都有边界保护

---

## 🎯 **模型创新点**

### **1. 自适应压缩策略**
根据颜色的饱和度和亮度特征，动态调整压缩参数，而非固定的线性映射。

### **2. 感知一致性保持**
使用CIE Lab色彩空间进行色差计算，确保数值结果与人眼感知一致。

### **3. 几何边界优化**
通过射线-边界交点算法，找到最优的映射目标点，保持色彩的相对关系。

### **4. 多层次质量评估**
建立了从像素级到图像级的完整质量评估体系，便于算法优化和工程应用。

---

## 📚 **数学理论基础**

### **色彩科学理论**
- **CIE 1931色度学系统**：建立了设备无关的颜色描述标准
- **Lab均匀色彩空间**：提供感知一致的色差度量
- **色域映射理论**：在保持视觉质量的前提下进行色彩转换

### **几何算法理论**
- **计算几何**：点在多边形内判断、射线求交算法
- **仿射变换**：色域间的几何映射关系
- **优化理论**：约束优化问题的求解方法

### **数值计算理论**
- **数值稳定性**：避免除零和浮点溢出
- **误差控制**：控制累积误差在可接受范围内
- **边界处理**：确保所有计算结果在有效域内

这个数学模型在理论严谨性和工程实用性之间取得了良好的平衡，为LED显示屏颜色转换提供了完整的解决方案。
