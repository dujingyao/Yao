# é™„å½•Aï¼šé—®é¢˜ä¸€æ ¸å¿ƒä»£ç 
## A.1 OptimizedColorSpaceConverter ç±»
```python
import numpy as np
import pandas as pd
from colormath.color_objects import sRGBColor, XYZColor, LabColor
from colormath.color_conversions import convert_color
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt
class OptimizedColorSpaceConverter:
Â  Â  """ä¼˜åŒ–çš„è‰²å½©ç©ºé—´è½¬æ¢å™¨ - ç”¨äºé—®é¢˜ä¸€çš„LEDé¢œè‰²åˆ†æå’Œå»ºæ¨¡"""
Â  Â  def __init__(self, excel_file_path):
Â  Â  Â  Â  self.excel_file = excel_file_path
Â  Â  Â  Â  self.led_data = {}
Â  Â  Â  Â  self.color_gamuts = {}
Â  Â  Â  Â  self.conversion_matrices = {}
Â  Â  def load_led_data(self):
Â  Â  Â  Â  """åŠ è½½LEDæ•°æ®ä»Excelæ–‡ä»¶çš„9ä¸ªå·¥ä½œè¡¨"""
Â  Â  Â  Â  sheet_names = ['R_R', 'R_G', 'R_B', 'G_R', 'G_G', 'G_B', 'B_R', 'B_G', 'B_B']
Â  Â  Â  Â  for sheet in sheet_names:
Â  Â  Â  Â  Â  Â  try:
Â  Â  Â  Â  Â  Â  Â  Â  df = pd.read_excel(self.excel_file, sheet_name=sheet, header=None)
Â  Â  Â  Â  Â  Â  Â  Â  self.led_data[sheet] = df.values
Â  Â  Â  Â  Â  Â  Â  Â  print(f"âœ… æˆåŠŸåŠ è½½å·¥ä½œè¡¨ {sheet}: {df.shape}")
Â  Â  Â  Â  Â  Â  except Exception as e:
Â  Â  Â  Â  Â  Â  Â  Â  print(f"âŒ åŠ è½½å·¥ä½œè¡¨ {sheet} å¤±è´¥: {e}")
Â  Â  Â  Â  return self.led_data
Â  Â  def rgb_to_xyz(self, rgb_values):
Â  Â  Â  Â  # å½’ä¸€åŒ–åˆ°0-1èŒƒå›´
Â  Â  Â  Â  rgb_normalized = np.array(rgb_values) / 255.0
Â  Â  Â  Â  # ä¼½é©¬æ ¡æ­£
Â  Â  Â  Â  def gamma_correction(channel):
Â  Â  Â  Â  Â  Â  if channel <= 0.04045:
Â  Â  Â  Â  Â  Â  Â  Â  return channel / 12.92
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  return np.power((channel + 0.055) / 1.055, 2.4)
Â  Â  Â  Â  rgb_linear = np.array([gamma_correction(c) for c in rgb_normalized])
Â  Â  Â  Â  # sRGBåˆ°XYZè½¬æ¢çŸ©é˜µ
Â  Â  Â  Â  conversion_matrix = np.array([
Â  Â  Â  Â  Â  Â  [0.4124564, 0.3575761, 0.1804375],
Â  Â  Â  Â  Â  Â  [0.2126729, 0.7151522, 0.0721750],
Â  Â  Â  Â  Â  Â  [0.0193339, 0.1191920, 0.9503041]
Â  Â  Â  Â  ])
Â  Â  Â  Â  xyz = np.dot(conversion_matrix, rgb_linear)
Â  Â  Â  Â  return xyz * 100 Â # ç¼©æ”¾åˆ°æ ‡å‡†XYZèŒƒå›´
Â  Â  def xyz_to_lab(self, xyz_values):
Â  Â  Â  Â  # D65æ ‡å‡†å…‰æºç™½ç‚¹
Â  Â  Â  Â  xyz_n = np.array([95.047, 100.000, 108.883])
Â  Â  Â  Â  # å½’ä¸€åŒ–
Â  Â  Â  Â  xyz_norm = xyz_values / xyz_n
Â  Â  Â  Â  # få‡½æ•°
Â  Â  Â  Â  def f_function(t):
Â  Â  Â  Â  Â  Â  delta = 6/29
Â  Â  Â  Â  Â  Â  if t > delta**3:
Â  Â  Â  Â  Â  Â  Â  Â  return np.power(t, 1/3)
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  return t / (3 * delta**2) + 4/29
Â  Â  Â  Â  fx = f_function(xyz_norm[0])
Â  Â  Â  Â  fy = f_function(xyz_norm[1])
Â  Â  Â  Â  fz = f_function(xyz_norm[2])
Â  Â  Â  Â  # Labè®¡ç®—
Â  Â  Â  Â  L = 116 * fy - 16
Â  Â  Â  Â  a = 500 * (fx - fy)
Â  Â  Â  Â  b = 200 * (fy - fz)
Â  Â  Â  Â  return np.array([L, a, b])
Â  Â  def build_rgb_arrays(self):
Â  Â  Â  Â  rgb_arrays = {}
Â  Â  Â  Â  # çº¢è‰²LEDç»„åˆ (Ré€šé“ä¸»å¯¼)
Â  Â  Â  Â  red_rgb = np.stack([
Â  Â  Â  Â  Â  Â  self.led_data['R_R'], Â # Ré€šé“
Â  Â  Â  Â  Â  Â  self.led_data['R_G'], Â # Gé€šé“
Â  Â  Â  Â  Â  Â  self.led_data['R_B'] Â  # Bé€šé“
Â  Â  Â  Â  ], axis=-1)
Â  Â  Â  Â  # ç»¿è‰²LEDç»„åˆ (Gé€šé“ä¸»å¯¼)
Â  Â  Â  Â  green_rgb = np.stack([
Â  Â  Â  Â  Â  Â  self.led_data['G_R'], Â # Ré€šé“
Â  Â  Â  Â  Â  Â  self.led_data['G_G'], Â # Gé€šé“
Â  Â  Â  Â  Â  Â  self.led_data['G_B'] Â  # Bé€šé“
Â  Â  Â  Â  ], axis=-1)
Â  Â  Â  Â  # è“è‰²LEDç»„åˆ (Bé€šé“ä¸»å¯¼)
Â  Â  Â  Â  blue_rgb = np.stack([
Â  Â  Â  Â  Â  Â  self.led_data['B_R'], Â # Ré€šé“
Â  Â  Â  Â  Â  Â  self.led_data['B_G'], Â # Gé€šé“
Â  Â  Â  Â  Â  Â  self.led_data['B_B'] Â  # Bé€šé“
Â  Â  Â  Â  ], axis=-1)
Â  Â  Â  Â  rgb_arrays = {
Â  Â  Â  Â  Â  Â  'red_rgb': red_rgb,
Â  Â  Â  Â  Â  Â  'green_rgb': green_rgb,
Â  Â  Â  Â  Â  Â  'blue_rgb': blue_rgb
Â  Â  Â  Â  }
Â  Â  Â  Â  return rgb_arrays
Â  Â  def calculate_color_gamut(self, rgb_array, color_name):
Â  Â  Â  Â  # è½¬æ¢æ‰€æœ‰åƒç´ åˆ°XYZ
Â  Â  Â  Â  height, width, _ = rgb_array.shape
Â  Â  Â  Â  xyz_points = []
Â  Â  Â  Â  for i in range(height):
Â  Â  Â  Â  Â  Â  for j in range(width):
Â  Â  Â  Â  Â  Â  Â  Â  rgb = rgb_array[i, j]
Â  Â  Â  Â  Â  Â  Â  Â  if np.sum(rgb) > 0: Â # å¿½ç•¥é»‘è‰²åƒç´ 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  xyz = self.rgb_to_xyz(rgb)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  xyz_points.append(xyz)
Â  Â  Â  Â  xyz_points = np.array(xyz_points)
Â  Â  Â  Â  # è®¡ç®—xyè‰²åº¦åæ ‡
Â  Â  Â  Â  xy_points = []
Â  Â  Â  Â  for xyz in xyz_points:
Â  Â  Â  Â  Â  Â  if np.sum(xyz) > 0:
Â  Â  Â  Â  Â  Â  Â  Â  x = xyz[0] / np.sum(xyz)
Â  Â  Â  Â  Â  Â  Â  Â  y = xyz[1] / np.sum(xyz)
Â  Â  Â  Â  Â  Â  Â  Â  xy_points.append([x, y])
Â  Â  Â  Â  xy_points = np.array(xy_points)
Â  Â  Â  Â  # è®¡ç®—å‡¸åŒ…ï¼ˆè‰²åŸŸè¾¹ç•Œï¼‰
Â  Â  Â  Â  if len(xy_points) > 3:
Â  Â  Â  Â  Â  Â  hull = ConvexHull(xy_points)
Â  Â  Â  Â  Â  Â  gamut_boundary = xy_points[hull.vertices]
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  gamut_boundary = xy_points
Â  Â  Â  Â  # è®¡ç®—è‰²åŸŸé¢ç§¯
Â  Â  Â  Â  if len(gamut_boundary) > 2:
Â  Â  Â  Â  Â  Â  gamut_area = ConvexHull(gamut_boundary).volume
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  gamut_area = 0
Â  Â  Â  Â  gamut_info = {
Â  Â  Â  Â  Â  Â  'xy_points': xy_points,
Â  Â  Â  Â  Â  Â  'boundary': gamut_boundary,
Â  Â  Â  Â  Â  Â  'area': gamut_area,
Â  Â  Â  Â  Â  Â  'center': np.mean(xy_points, axis=0),
Â  Â  Â  Â  Â  Â  'std': np.std(xy_points, axis=0)
Â  Â  Â  Â  }
Â  Â  Â  Â  self.color_gamuts[color_name] = gamut_info
Â  Â  Â  Â  return gamut_info
Â  Â  def analyze_color_uniformity(self, rgb_array, color_name):
Â  Â  Â  Â  # å±•å¹³æ•°ç»„
Â  Â  Â  Â  rgb_flat = rgb_array.reshape(-1, 3)
Â  Â  Â  Â  # è¿‡æ»¤æœ‰æ•ˆåƒç´ 
Â  Â  Â  Â  valid_pixels = rgb_flat[np.sum(rgb_flat, axis=1) > 0]
Â  Â  Â  Â  if len(valid_pixels) == 0:
Â  Â  Â  Â  Â  Â  return None
Â  Â  Â  Â  # è®¡ç®—ç»Ÿè®¡æŒ‡æ ‡
Â  Â  Â  Â  mean_rgb = np.mean(valid_pixels, axis=0)
Â  Â  Â  Â  std_rgb = np.std(valid_pixels, axis=0)
Â  Â  Â  Â  cv_rgb = std_rgb / (mean_rgb + 1e-8) Â # å˜å¼‚ç³»æ•°
Â  Â  Â  Â  # è®¡ç®—é¢œè‰²ä¸€è‡´æ€§æŒ‡æ ‡
Â  Â  Â  Â  color_distances = []
Â  Â  Â  Â  for pixel in valid_pixels:
Â  Â  Â  Â  Â  Â  distance = np.linalg.norm(pixel - mean_rgb)
Â  Â  Â  Â  Â  Â  color_distances.append(distance)
Â  Â  Â  Â  uniformity_metrics = {
Â  Â  Â  Â  Â  Â  'mean_rgb': mean_rgb,
Â  Â  Â  Â  Â  Â  'std_rgb': std_rgb,
Â  Â  Â  Â  Â  Â  'cv_rgb': cv_rgb,
Â  Â  Â  Â  Â  Â  'mean_distance': np.mean(color_distances),
Â  Â  Â  Â  Â  Â  'max_distance': np.max(color_distances),
Â  Â  Â  Â  Â  Â  'uniformity_index': 1 / (1 + np.mean(cv_rgb)) Â # 0-1ï¼Œè¶Šå¤§è¶Šå‡åŒ€
Â  Â  Â  Â  }
Â  Â  Â  Â  return uniformity_metrics
Â  Â  def barycentric_coordinates(self, point, triangle):
Â  Â  Â  Â  x, y = point
Â  Â  Â  Â  x1, y1 = triangle[0]
Â  Â  Â  Â  x2, y2 = triangle[1]
Â  Â  Â  Â  x3, y3 = triangle[2]
Â  Â  Â  Â  # è®¡ç®—é¢ç§¯
Â  Â  Â  Â  denominator = (y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3)
Â  Â  Â  Â  if abs(denominator) < 1e-10:
Â  Â  Â  Â  Â  Â  return np.array([0, 0, 0])
Â  Â  Â  Â  u = ((y2 - y3)*(x - x3) + (x3 - x2)*(y - y3)) / denominator
Â  Â  Â  Â  v = ((y3 - y1)*(x - x3) + (x1 - x3)*(y - y3)) / denominator
Â  Â  Â  Â  w = 1 - u - v
Â  Â  Â  Â  return np.array([u, v, w])
Â  Â  def gamut_mapping(self, source_gamut, target_gamut):
Â  Â  Â  Â  # è·å–è‰²åŸŸä¸­å¿ƒç‚¹
Â  Â  Â  Â  source_center = source_gamut['center']
Â  Â  Â  Â  target_center = target_gamut['center']
Â  Â  Â  Â  # è®¡ç®—ç¼©æ”¾å› å­
Â  Â  Â  Â  source_area = source_gamut['area']
Â  Â  Â  Â  target_area = target_gamut['area']
Â  Â  Â  Â  scale_factor = np.sqrt(target_area / (source_area + 1e-8))
Â  Â  Â  Â  # æ„å»ºå˜æ¢çŸ©é˜µï¼šå¹³ç§» + ç¼©æ”¾
Â  Â  Â  Â  transform_matrix = np.array([
Â  Â  Â  Â  Â  Â  [scale_factor, 0, target_center[0] - scale_factor * source_center[0]],
Â  Â  Â  Â  Â  Â  [0, scale_factor, target_center[1] - scale_factor * source_center[1]],
Â  Â  Â  Â  Â  Â  [0, 0, 1]
Â  Â  Â  Â  ])
Â  Â  Â  Â  return transform_matrix
Â  Â  def comprehensive_analysis(self):
Â  Â  Â  Â  print("ğŸ” å¼€å§‹ç»¼åˆè‰²å½©ç©ºé—´åˆ†æ...")
Â  Â  Â  Â  self.load_led_data()
Â  Â  Â  Â  rgb_arrays = self.build_rgb_arrays()
Â  Â  Â  Â  analysis_results = {}
Â  Â  Â  Â  for color_name, rgb_array in rgb_arrays.items():
Â  Â  Â  Â  Â  Â  print(f"\nğŸ“Š åˆ†æ {color_name}...")
Â  Â  Â  Â  Â  Â  gamut_info = self.calculate_color_gamut(rgb_array, color_name)
Â  Â  Â  Â  Â  Â  uniformity_info = self.analyze_color_uniformity(rgb_array, color_name)
Â  Â  Â  Â  Â  Â  analysis_results[color_name] = {
Â  Â  Â  Â  Â  Â  Â  Â  'gamut': gamut_info,
Â  Â  Â  Â  Â  Â  Â  Â  'uniformity': uniformity_info,
Â  Â  Â  Â  Â  Â  Â  Â  'rgb_statistics': {
Â  Â  Â  Â  Â  Â  Â    Â  Â  'shape': rgb_array.shape,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'mean': np.mean(rgb_array, axis=(0,1)),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'std': np.std(rgb_array, axis=(0,1)),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'min': np.min(rgb_array, axis=(0,1)),
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'max': np.max(rgb_array, axis=(0,1))
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  print("âœ… ç»¼åˆåˆ†æå®Œæˆï¼")
Â  Â  Â  Â  return analysis_results
if __name__ == "__main__":
Â  Â  converter = OptimizedColorSpaceConverter('LEDæ•°æ®.xlsx')
Â  Â  results = converter.comprehensive_analysis()
Â  Â  for color, analysis in results.items():
Â  Â  Â  Â  print(f"\n=== {color.upper()} åˆ†æç»“æœ ===")
Â  Â  Â  Â  print(f"è‰²åŸŸé¢ç§¯: {analysis['gamut']['area']:.6f}")
Â  Â  Â  Â  print(f"å‡åŒ€æ€§æŒ‡æ•°: {analysis['uniformity']['uniformity_index']:.4f}")
Â  Â  Â  Â  print(f"RGBå‡å€¼: {analysis['rgb_statistics']['mean']}")
```
## A.2 æ ¸å¿ƒç®—æ³•å‡½æ•°
```python
def rgb_to_xyz_vectorized(rgb_array):
Â  Â  rgb_norm = rgb_array / 255.0
Â  Â  def gamma_correct_vectorized(rgb):
Â  Â  Â  Â  linear = np.where(rgb <= 0.04045,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â rgb / 12.92,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â np.power((rgb + 0.055) / 1.055, 2.4))
Â  Â  Â  Â  return linear
Â  Â  rgb_linear = gamma_correct_vectorized(rgb_norm)
Â  Â  M = np.array([
Â  Â  Â  Â  [0.4124564, 0.3575761, 0.1804375],
Â  Â  Â  Â  [0.2126729, 0.7151522, 0.0721750],
Â  Â  Â  Â  [0.0193339, 0.1191920, 0.9503041]
Â  Â  ])
Â  Â  xyz = np.dot(rgb_linear, M.T) * 100
Â  Â  return xyz
def calculate_delta_e(lab1, lab2):
Â  Â  delta_l = lab1[0] - lab2[0]
Â  Â  delta_a = lab1[1] - lab2[1]
Â  Â  delta_b = lab1[2] - lab2[2]
Â  Â  delta_e = np.sqrt(delta_l**2 + delta_a**2 + delta_b**2)
Â  Â  return delta_e
def optimal_white_point_estimation(rgb_arrays):
Â  Â  all_pixels = []
Â  Â  for color_name, rgb_array in rgb_arrays.items():
Â  Â  Â  Â  brightness = np.sum(rgb_array, axis=-1)
Â  Â  Â  Â  high_brightness_mask = brightness > np.percentile(brightness, 95)
Â  Â  Â  Â  high_brightness_pixels = rgb_array[high_brightness_mask]
Â  Â  Â  Â  all_pixels.extend(high_brightness_pixels)
Â  Â  all_pixels = np.array(all_pixels)
Â  Â  # è®¡ç®—ç™½ç‚¹ï¼ˆé«˜äº®åº¦åƒç´ çš„å¹³å‡å€¼ï¼‰
Â  Â  white_point = np.mean(all_pixels, axis=0)
Â  Â  return white_point
```
## A.3 å¯è§†åŒ–å‡½æ•°
```python
def plot_color_gamut_comparison(gamuts_dict, title="è‰²åŸŸå¯¹æ¯”åˆ†æ"):
Â  Â  plt.figure(figsize=(12, 10))
Â  Â  colors = ['red', 'green', 'blue']
Â  Â  gamut_names = ['red_rgb', 'green_rgb', 'blue_rgb']
Â  Â  for i, (name, color) in enumerate(zip(gamut_names, colors)):
Â  Â  Â  Â  if name in gamuts_dict:
Â  Â  Â  Â  Â  Â  gamut = gamuts_dict[name]
Â  Â  Â  Â  Â  Â  boundary = gamut['boundary']
Â  Â  Â  Â  Â  Â  boundary_closed = np.vstack([boundary, boundary[0]])
Â  Â  Â  Â  Â  Â  plt.plot(boundary_closed[:, 0], boundary_closed[:, 1],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color=color, linewidth=2, label=f'{name} è‰²åŸŸè¾¹ç•Œ')
Â  Â  Â  Â  Â  Â  plt.fill(boundary_closed[:, 0], boundary_closed[:, 1],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  color=color, alpha=0.2)
Â  Â  Â  Â  Â  Â  center = gamut['center']
Â  Â  Â  Â  Â  Â  plt.plot(center[0], center[1], 'o', color=color,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  markersize=8, label=f'{name} ä¸­å¿ƒ')
Â  Â  plt.xlabel('x (CIE 1931)')
Â  Â  plt.ylabel('y (CIE 1931)')
Â  Â  plt.title(title)
Â  Â  plt.legend()
Â  Â  plt.grid(True, alpha=0.3)
Â  Â  plt.axis('equal')
Â  Â  plt.tight_layout()
Â  Â  plt.show()
def plot_uniformity_analysis(uniformity_results):
Â  Â  fig, axes = plt.subplots(2, 2, figsize=(15, 12))
Â  Â  colors = ['red', 'green', 'blue']
Â  Â  color_names = ['red_rgb', 'green_rgb', 'blue_rgb']
Â  Â  cv_data = []
Â  Â  labels = []
Â  Â  for name in color_names:
Â  Â  Â  Â  if name in uniformity_results and uniformity_results[name]:
Â  Â  Â  Â  Â  Â  cv_rgb = uniformity_results[name]['cv_rgb']
Â  Â  Â  Â  Â  Â  cv_data.append(cv_rgb)
Â  Â  Â  Â  Â  Â  labels.append(name.replace('_rgb', '').title())
Â  Â  if cv_data:
Â  Â  Â  Â  cv_data = np.array(cv_data)
Â  Â  Â  Â  x = np.arange(len(labels))
Â  Â  Â  Â  width = 0.25
Â  Â  Â  Â  axes[0,0].bar(x - width, cv_data[:, 0], width, label='Ré€šé“', color='red', alpha=0.7)
Â  Â  Â  Â  axes[0,0].bar(x, cv_data[:, 1], width, label='Gé€šé“', color='green', alpha=0.7)
Â  Â  Â  Â  axes[0,0].bar(x + width, cv_data[:, 2], width, label='Bé€šé“', color='blue', alpha=0.7)
Â  Â  Â  Â  axes[0,0].set_xlabel('LEDé¢œè‰²')
Â  Â  Â  Â  axes[0,0].set_ylabel('å˜å¼‚ç³»æ•° (CV)')
Â  Â  Â  Â  axes[0,0].set_title('é¢œè‰²é€šé“å˜å¼‚ç³»æ•°å¯¹æ¯”')
Â  Â  Â  Â  axes[0,0].set_xticks(x)
Â  Â  Â  Â  axes[0,0].set_xticklabels(labels)
Â  Â  Â  Â  axes[0,0].legend()
Â  Â  Â  Â  axes[0,0].grid(True, alpha=0.3)
Â  Â  uniformity_indices = []
Â  Â  for name in color_names:
Â  Â  Â  Â  if name in uniformity_results and uniformity_results[name]:
Â  Â  Â  Â  Â  Â  uniformity_indices.append(uniformity_results[name]['uniformity_index'])
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  uniformity_indices.append(0)
Â  Â  axes[0,1].bar(labels, uniformity_indices, color=colors[:len(labels)], alpha=0.7)
Â  Â  axes[0,1].set_xlabel('LEDé¢œè‰²')
Â  Â  axes[0,1].set_ylabel('å‡åŒ€æ€§æŒ‡æ•°')
Â  Â  axes[0,1].set_title('é¢œè‰²å‡åŒ€æ€§æŒ‡æ•°å¯¹æ¯”')
Â  Â  axes[0,1].grid(True, alpha=0.3)
Â  Â  mean_distances = []
Â  Â  for name in color_names:
Â  Â  Â  Â  if name in uniformity_results and uniformity_results[name]:
Â  Â  Â  Â  Â  Â  mean_distances.append(uniformity_results[name]['mean_distance'])
Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  mean_distances.append(0)
Â  Â  axes[1,0].bar(labels, mean_distances, color=colors[:len(labels)], alpha=0.7)
Â  Â  axes[1,0].set_xlabel('LEDé¢œè‰²')
Â  Â  axes[1,0].set_ylabel('å¹³å‡è‰²å·®è·ç¦»')
Â  Â  axes[1,0].set_title('é¢œè‰²ä¸€è‡´æ€§åˆ†æ')
Â  Â  axes[1,0].grid(True, alpha=0.3)
Â  Â  std_data = []
Â  Â  for name in color_names:
Â  Â  Â  Â  if name in uniformity_results and uniformity_results[name]:
Â  Â  Â  Â  Â  Â  std_rgb = uniformity_results[name]['std_rgb']
Â  Â  Â  Â  Â  Â  std_data.append(std_rgb)
Â  Â  if std_data:
Â  Â  Â  Â  std_data = np.array(std_data)
Â  Â  Â  Â  im = axes[1,1].imshow(std_data, cmap='YlOrRd', aspect='auto')
Â  Â  Â  Â  axes[1,1].set_xlabel('RGBé€šé“')
Â  Â  Â  Â  axes[1,1].set_ylabel('LEDé¢œè‰²')
Â  Â  Â  Â  axes[1,1].set_title('RGBæ ‡å‡†å·®çƒ­å›¾')
Â  Â  Â  Â  axes[1,1].set_xticks([0, 1, 2])
Â  Â  Â  Â  axes[1,1].set_xticklabels(['R', 'G', 'B'])
Â  Â  Â  Â  axes[1,1].set_yticks(range(len(labels)))
Â  Â  Â  Â  axes[1,1].set_yticklabels(labels)
Â  Â  Â  Â  plt.colorbar(im, ax=axes[1,1])
Â  Â  Â  Â  for i in range(len(labels)):
Â  Â  Â  Â  Â  Â  for j in range(3):
Â  Â  Â  Â  Â  Â  Â  Â  axes[1,1].text(j, i, f'{std_data[i,j]:.1f}',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ha='center', va='center', color='white' if std_data[i,j] > np.max(std_data)/2 else 'black')
Â  Â  plt.tight_layout()
Â  Â  plt.show()
```