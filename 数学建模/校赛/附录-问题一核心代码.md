# 附录A：问题一核心代码
## A.1 OptimizedColorSpaceConverter 类
```python
import numpy as np
import pandas as pd
from colormath.color_objects import sRGBColor, XYZColor, LabColor
from colormath.color_conversions import convert_color
from scipy.spatial import ConvexHull
import matplotlib.pyplot as plt
class OptimizedColorSpaceConverter:
    """优化的色彩空间转换器 - 用于问题一的LED颜色分析和建模"""
    def __init__(self, excel_file_path):
        self.excel_file = excel_file_path
        self.led_data = {}
        self.color_gamuts = {}
        self.conversion_matrices = {}
    def load_led_data(self):
        """加载LED数据从Excel文件的9个工作表"""
        sheet_names = ['R_R', 'R_G', 'R_B', 'G_R', 'G_G', 'G_B', 'B_R', 'B_G', 'B_B']
        for sheet in sheet_names:
            try:
                df = pd.read_excel(self.excel_file, sheet_name=sheet, header=None)
                self.led_data[sheet] = df.values
                print(f"✅ 成功加载工作表 {sheet}: {df.shape}")
            except Exception as e:
                print(f"❌ 加载工作表 {sheet} 失败: {e}")
        return self.led_data
    def rgb_to_xyz(self, rgb_values):
        # 归一化到0-1范围
        rgb_normalized = np.array(rgb_values) / 255.0
        # 伽马校正
        def gamma_correction(channel):
            if channel <= 0.04045:
                return channel / 12.92
            else:
                return np.power((channel + 0.055) / 1.055, 2.4)
        rgb_linear = np.array([gamma_correction(c) for c in rgb_normalized])
        # sRGB到XYZ转换矩阵
        conversion_matrix = np.array([
            [0.4124564, 0.3575761, 0.1804375],
            [0.2126729, 0.7151522, 0.0721750],
            [0.0193339, 0.1191920, 0.9503041]
        ])
        xyz = np.dot(conversion_matrix, rgb_linear)
        return xyz * 100  # 缩放到标准XYZ范围
    def xyz_to_lab(self, xyz_values):
        # D65标准光源白点
        xyz_n = np.array([95.047, 100.000, 108.883])
        # 归一化
        xyz_norm = xyz_values / xyz_n
        # f函数
        def f_function(t):
            delta = 6/29
            if t > delta**3:
                return np.power(t, 1/3)
            else:
                return t / (3 * delta**2) + 4/29
        fx = f_function(xyz_norm[0])
        fy = f_function(xyz_norm[1])
        fz = f_function(xyz_norm[2])
        # Lab计算
        L = 116 * fy - 16
        a = 500 * (fx - fy)
        b = 200 * (fy - fz)
        return np.array([L, a, b])
    def build_rgb_arrays(self):
        rgb_arrays = {}
        # 红色LED组合 (R通道主导)
        red_rgb = np.stack([
            self.led_data['R_R'],  # R通道
            self.led_data['R_G'],  # G通道
            self.led_data['R_B']   # B通道
        ], axis=-1)
        # 绿色LED组合 (G通道主导)
        green_rgb = np.stack([
            self.led_data['G_R'],  # R通道
            self.led_data['G_G'],  # G通道
            self.led_data['G_B']   # B通道
        ], axis=-1)
        # 蓝色LED组合 (B通道主导)
        blue_rgb = np.stack([
            self.led_data['B_R'],  # R通道
            self.led_data['B_G'],  # G通道
            self.led_data['B_B']   # B通道
        ], axis=-1)
        rgb_arrays = {
            'red_rgb': red_rgb,
            'green_rgb': green_rgb,
            'blue_rgb': blue_rgb
        }
        return rgb_arrays
    def calculate_color_gamut(self, rgb_array, color_name):
        # 转换所有像素到XYZ
        height, width, _ = rgb_array.shape
        xyz_points = []
        for i in range(height):
            for j in range(width):
                rgb = rgb_array[i, j]
                if np.sum(rgb) > 0:  # 忽略黑色像素
                    xyz = self.rgb_to_xyz(rgb)
                    xyz_points.append(xyz)
        xyz_points = np.array(xyz_points)
        # 计算xy色度坐标
        xy_points = []
        for xyz in xyz_points:
            if np.sum(xyz) > 0:
                x = xyz[0] / np.sum(xyz)
                y = xyz[1] / np.sum(xyz)
                xy_points.append([x, y])
        xy_points = np.array(xy_points)
        # 计算凸包（色域边界）
        if len(xy_points) > 3:
            hull = ConvexHull(xy_points)
            gamut_boundary = xy_points[hull.vertices]
        else:
            gamut_boundary = xy_points
        # 计算色域面积
        if len(gamut_boundary) > 2:
            gamut_area = ConvexHull(gamut_boundary).volume
        else:
            gamut_area = 0
        gamut_info = {
            'xy_points': xy_points,
            'boundary': gamut_boundary,
            'area': gamut_area,
            'center': np.mean(xy_points, axis=0),
            'std': np.std(xy_points, axis=0)
        }
        self.color_gamuts[color_name] = gamut_info
        return gamut_info
    def analyze_color_uniformity(self, rgb_array, color_name):
        # 展平数组
        rgb_flat = rgb_array.reshape(-1, 3)
        # 过滤有效像素
        valid_pixels = rgb_flat[np.sum(rgb_flat, axis=1) > 0]
        if len(valid_pixels) == 0:
            return None
        # 计算统计指标
        mean_rgb = np.mean(valid_pixels, axis=0)
        std_rgb = np.std(valid_pixels, axis=0)
        cv_rgb = std_rgb / (mean_rgb + 1e-8)  # 变异系数
        # 计算颜色一致性指标
        color_distances = []
        for pixel in valid_pixels:
            distance = np.linalg.norm(pixel - mean_rgb)
            color_distances.append(distance)
        uniformity_metrics = {
            'mean_rgb': mean_rgb,
            'std_rgb': std_rgb,
            'cv_rgb': cv_rgb,
            'mean_distance': np.mean(color_distances),
            'max_distance': np.max(color_distances),
            'uniformity_index': 1 / (1 + np.mean(cv_rgb))  # 0-1，越大越均匀
        }
        return uniformity_metrics
    def barycentric_coordinates(self, point, triangle):
        x, y = point
        x1, y1 = triangle[0]
        x2, y2 = triangle[1]
        x3, y3 = triangle[2]
        # 计算面积
        denominator = (y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3)
        if abs(denominator) < 1e-10:
            return np.array([0, 0, 0])
        u = ((y2 - y3)*(x - x3) + (x3 - x2)*(y - y3)) / denominator
        v = ((y3 - y1)*(x - x3) + (x1 - x3)*(y - y3)) / denominator
        w = 1 - u - v
        return np.array([u, v, w])
    def gamut_mapping(self, source_gamut, target_gamut):
        # 获取色域中心点
        source_center = source_gamut['center']
        target_center = target_gamut['center']
        # 计算缩放因子
        source_area = source_gamut['area']
        target_area = target_gamut['area']
        scale_factor = np.sqrt(target_area / (source_area + 1e-8))
        # 构建变换矩阵：平移 + 缩放
        transform_matrix = np.array([
            [scale_factor, 0, target_center[0] - scale_factor * source_center[0]],
            [0, scale_factor, target_center[1] - scale_factor * source_center[1]],
            [0, 0, 1]
        ])
        return transform_matrix
    def comprehensive_analysis(self):
        print("🔍 开始综合色彩空间分析...")
        self.load_led_data()
        rgb_arrays = self.build_rgb_arrays()
        analysis_results = {}
        for color_name, rgb_array in rgb_arrays.items():
            print(f"\n📊 分析 {color_name}...")
            gamut_info = self.calculate_color_gamut(rgb_array, color_name)
            uniformity_info = self.analyze_color_uniformity(rgb_array, color_name)
            analysis_results[color_name] = {
                'gamut': gamut_info,
                'uniformity': uniformity_info,
                'rgb_statistics': {
                    'shape': rgb_array.shape,
                    'mean': np.mean(rgb_array, axis=(0,1)),
                    'std': np.std(rgb_array, axis=(0,1)),
                    'min': np.min(rgb_array, axis=(0,1)),
                    'max': np.max(rgb_array, axis=(0,1))
                }
            }
        print("✅ 综合分析完成！")
        return analysis_results
if __name__ == "__main__":
    converter = OptimizedColorSpaceConverter('LED数据.xlsx')
    results = converter.comprehensive_analysis()
    for color, analysis in results.items():
        print(f"\n=== {color.upper()} 分析结果 ===")
        print(f"色域面积: {analysis['gamut']['area']:.6f}")
        print(f"均匀性指数: {analysis['uniformity']['uniformity_index']:.4f}")
        print(f"RGB均值: {analysis['rgb_statistics']['mean']}")
```
## A.2 核心算法函数
```python
def rgb_to_xyz_vectorized(rgb_array):
    rgb_norm = rgb_array / 255.0
    def gamma_correct_vectorized(rgb):
        linear = np.where(rgb <= 0.04045,
                         rgb / 12.92,
                         np.power((rgb + 0.055) / 1.055, 2.4))
        return linear
    rgb_linear = gamma_correct_vectorized(rgb_norm)
    M = np.array([
        [0.4124564, 0.3575761, 0.1804375],
        [0.2126729, 0.7151522, 0.0721750],
        [0.0193339, 0.1191920, 0.9503041]
    ])
    xyz = np.dot(rgb_linear, M.T) * 100
    return xyz
def calculate_delta_e(lab1, lab2):
    delta_l = lab1[0] - lab2[0]
    delta_a = lab1[1] - lab2[1]
    delta_b = lab1[2] - lab2[2]
    delta_e = np.sqrt(delta_l**2 + delta_a**2 + delta_b**2)
    return delta_e
def optimal_white_point_estimation(rgb_arrays):
    all_pixels = []
    for color_name, rgb_array in rgb_arrays.items():
        brightness = np.sum(rgb_array, axis=-1)
        high_brightness_mask = brightness > np.percentile(brightness, 95)
        high_brightness_pixels = rgb_array[high_brightness_mask]
        all_pixels.extend(high_brightness_pixels)
    all_pixels = np.array(all_pixels)
    # 计算白点（高亮度像素的平均值）
    white_point = np.mean(all_pixels, axis=0)
    return white_point
```
## A.3 可视化函数
```python
def plot_color_gamut_comparison(gamuts_dict, title="色域对比分析"):
    plt.figure(figsize=(12, 10))
    colors = ['red', 'green', 'blue']
    gamut_names = ['red_rgb', 'green_rgb', 'blue_rgb']
    for i, (name, color) in enumerate(zip(gamut_names, colors)):
        if name in gamuts_dict:
            gamut = gamuts_dict[name]
            boundary = gamut['boundary']
            boundary_closed = np.vstack([boundary, boundary[0]])
            plt.plot(boundary_closed[:, 0], boundary_closed[:, 1],
                    color=color, linewidth=2, label=f'{name} 色域边界')
            plt.fill(boundary_closed[:, 0], boundary_closed[:, 1],
                    color=color, alpha=0.2)
            center = gamut['center']
            plt.plot(center[0], center[1], 'o', color=color,
                    markersize=8, label=f'{name} 中心')
    plt.xlabel('x (CIE 1931)')
    plt.ylabel('y (CIE 1931)')
    plt.title(title)
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.axis('equal')
    plt.tight_layout()
    plt.show()
def plot_uniformity_analysis(uniformity_results):
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    colors = ['red', 'green', 'blue']
    color_names = ['red_rgb', 'green_rgb', 'blue_rgb']
    cv_data = []
    labels = []
    for name in color_names:
        if name in uniformity_results and uniformity_results[name]:
            cv_rgb = uniformity_results[name]['cv_rgb']
            cv_data.append(cv_rgb)
            labels.append(name.replace('_rgb', '').title())
    if cv_data:
        cv_data = np.array(cv_data)
        x = np.arange(len(labels))
        width = 0.25
        axes[0,0].bar(x - width, cv_data[:, 0], width, label='R通道', color='red', alpha=0.7)
        axes[0,0].bar(x, cv_data[:, 1], width, label='G通道', color='green', alpha=0.7)
        axes[0,0].bar(x + width, cv_data[:, 2], width, label='B通道', color='blue', alpha=0.7)
        axes[0,0].set_xlabel('LED颜色')
        axes[0,0].set_ylabel('变异系数 (CV)')
        axes[0,0].set_title('颜色通道变异系数对比')
        axes[0,0].set_xticks(x)
        axes[0,0].set_xticklabels(labels)
        axes[0,0].legend()
        axes[0,0].grid(True, alpha=0.3)
    uniformity_indices = []
    for name in color_names:
        if name in uniformity_results and uniformity_results[name]:
            uniformity_indices.append(uniformity_results[name]['uniformity_index'])
        else:
            uniformity_indices.append(0)
    axes[0,1].bar(labels, uniformity_indices, color=colors[:len(labels)], alpha=0.7)
    axes[0,1].set_xlabel('LED颜色')
    axes[0,1].set_ylabel('均匀性指数')
    axes[0,1].set_title('颜色均匀性指数对比')
    axes[0,1].grid(True, alpha=0.3)
    mean_distances = []
    for name in color_names:
        if name in uniformity_results and uniformity_results[name]:
            mean_distances.append(uniformity_results[name]['mean_distance'])
        else:
            mean_distances.append(0)
    axes[1,0].bar(labels, mean_distances, color=colors[:len(labels)], alpha=0.7)
    axes[1,0].set_xlabel('LED颜色')
    axes[1,0].set_ylabel('平均色差距离')
    axes[1,0].set_title('颜色一致性分析')
    axes[1,0].grid(True, alpha=0.3)
    std_data = []
    for name in color_names:
        if name in uniformity_results and uniformity_results[name]:
            std_rgb = uniformity_results[name]['std_rgb']
            std_data.append(std_rgb)
    if std_data:
        std_data = np.array(std_data)
        im = axes[1,1].imshow(std_data, cmap='YlOrRd', aspect='auto')
        axes[1,1].set_xlabel('RGB通道')
        axes[1,1].set_ylabel('LED颜色')
        axes[1,1].set_title('RGB标准差热图')
        axes[1,1].set_xticks([0, 1, 2])
        axes[1,1].set_xticklabels(['R', 'G', 'B'])
        axes[1,1].set_yticks(range(len(labels)))
        axes[1,1].set_yticklabels(labels)
        plt.colorbar(im, ax=axes[1,1])
        for i in range(len(labels)):
            for j in range(3):
                axes[1,1].text(j, i, f'{std_data[i,j]:.1f}',
                              ha='center', va='center', color='white' if std_data[i,j] > np.max(std_data)/2 else 'black')
    plt.tight_layout()
    plt.show()
```