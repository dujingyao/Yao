# prime 算法

```cpp
void prim(){
    memset(dist,0x3f,sizeof(dist));
    int res=0;
    dist[1]=0;
    for(int i=0;i<n;i++){
        int t=-1;
        //t <- 没有连通起来，但是距离连通部分最近的点;
        for(int j=1;j<=n;j++){
            if(!st[j]&&(t==-1||dist[j]<dist[t])){  //如果没有在树中,并且距离树的距离很短
                t=j; //第一轮循环,t=1,dist[t]=0
            }
        }
        if(dist[t]==0x3f3f3f3f){
            cout<<"impossible"<<endl;
            return;
        }
        st[t]=1;
        res+=dist[t];
        for(int j=1;j<=n;j++){
            if(dist[j]>Grap[t][j]&&!st[j]){
                dist[j]=Grap[t][j];
                pre[j]=t;
            }
        }
    }
    cout<<res;
}
```

# Kruskal算法求最小生树
## 并查集路径压缩技术实现
作用:高效地找到某个节点所在集合的根节点，并在这个过程中优化树的结构，使得后续的查找操作更加高效。
```cpp
int find(int a) {
    if(p[a] != a) 
        p[a] = find(p[a]);
    return p[a];
}
```
### 参数
a:需要查找其根结点的结点编号
### 功能
1. 查找根节点
2. 路径压缩
### 详细步骤
1. 检查当前结点是否为根节点
    ```cpp
    if(p[a]!=a)
    ```
    * 如果当前结点a的父节点不是它自己,说明它不是根节点.
2. 递归查找父节点的根节点
    ```cpp
    p[a]=find(p[a]);
    ```
    * 递归调用find函数,找到当前结点a的父节点的根节点,并将a的父节点更新为这个根节点.这一步实现了路径压缩,减少了树的高度.
3. 返回根节点
    ```cpp
    return p[a];
    ```
    * 最终返回查找到的根节点.
## 最终代码
### 用于存放边的结构体
```cpp
struct E{
int a;
int b;
int w;
bool operator < (const E& rhd){//通过边长进行排序
    return this->w<rhd.w;
}
}edg[N*2];
```
### 判断是否为同一集合的find函数,详情可查看并查集路径压缩技术实现
```cpp
int find(int a){   //找祖宗,主要用来判断是否有同一个根结点
if(p[a]!=a) p[a]=find(p[a]);
    return p[a];
}
```
### Kruskal 算法的函数
```cpp
void Kruskal(){
    for(int i=1;i<=m;i++){
        int pa=find(edg[i].a);
        int pb=find(edg[i].b);
        if(pa!=pb){  //如果不是同一个祖宗,也就是不在同一个集合当中
            res+=edg[i].w;
             p[pa]=pb;
            cnt++;  //保留的边数加一
        }
    }
}
```



