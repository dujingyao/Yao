# 数论
## 质数
### 质数的判定(试除法)
```cpp
bool check(int n){
    if(n==1) return false;
    if(n==2) return true;
    for(int i=2;i<=n/i;i++){
        if(n%i==0) return false;
    }
    return true;
}
```
### 分解质因数
```cpp
void devide(int x){
    for(int i=2;i<=x/i;i++){
        if(x/i==0){
            int s=0;
            while(x%i==0){
                x/=i;
                s++;
            }
            cout<<i<<' '<<s<<endl;
        }
    }
    if(x>1) cout<<x<<' '<<1<<endl;
}
```
### 筛质数
#### 朴素筛法
```cpp
void get(int n){
    for(int i=2;i<=n;i++){
        if(st[i]) continue;
        prime[dex++]=i;
        for(int j=i+i;j<=n;j+=i){
            st[j]=true;
        }
    }
}
```
#### 线性筛法
```cpp
void get2(int x) {
    for (int i=2;i<=x;i++) {  // 遍历从2到x的所有整数
        if (!st[i]) {  // 如果i还没有被标记为合数
            prime[dex++]=i;  // 那么i就是一个素数，将其加入素数列表
        }
        for (int j=0;prime[j]<=x/i;j++) {  // 对于每一个小于等于x/i的素数prime[j]
            st[prime[j]*i]=true;  // 标记prime[j] * i为合数
            if (i%prime[j]==0) break;  // 如果i可以被prime[j]整除，则退出循环
        }
    }
}
```
  * 如果 i 能够被 prime[j] 整除，即 i % prime[j] == 0，那么就跳出内层循环。这是因为，如果 i 能够被 prime[j] 整除，那么 i 的最小质因子就是 prime[j]。如果继续遍历更大的 prime[j]，那么 prime[j] * i 的最小质因子也会是 prime[j]，而这些合数已经在之前的迭代中被处理过了。因此，这样的优化可以避免重复标记，提高效率。
## 约数
### 什么是约数
  * 如果一个数a除以另一个数b的余数为0,即a%b==0,则b是a的约数.
### 试除法求约数
```cpp
for(int i=1;i<=m/i;i++){
    if(m%i==0){
        b.push_back(i);
        if(m/i!=i){
             b.push_back(m/i);
        }
    }
}
```
### 约数之和
设正整数n的质因数分解为n=$p_{1}^{e{1}}$$p_{2}^{e{2}}$$p_{3}^{e{3}}$...$p_{n}^{e{n}}$,其中$p_{1}$,$p_{2}$,...,$p_{n}$是不同的质数，且$e_{1}$，$e_{2}$，...,$e_{n}$是正整数。
  * 质因数：是指一个整数的质数因子。例如，12的质因数包括2和3，因为12可以分解成$2^{2}$*3。
  * 正约数：一个整数的所有正的因数。例如，12的正约数包括1,2,3,4,5,6,12。
    * 性质：一个整数的正约数之和可以用它的质因数分解来计算。