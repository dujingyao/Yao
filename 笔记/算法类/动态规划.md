# 背包问题
## 01背包问题
每个物品只能被选择一次，找到一种选择方案，在背包能装下的情况下，使得选择物品的总价值最大，然后输出总价值。
### 解决步骤
#### 1. 集合及集合状态
   
**集合，是一些方案的集合。**

用 g[i][j] 表示从前 i 种物品中进行选择，且总体积不大于 j 的各个选法获得的价值的集合。注意， **g[i][j] 是个集合**，表示一堆数：所有可能选出的价值。

例如 g[2][3] 从前 2 种物品中进行选择，且总体积不大于 3 的各个选法获得的价值的集合。选择方案有三种：都不选，价值为 0、选择第 1 个物品，价值为 2、选择第 2 个物品，价值为 4、选择第 1，第 2 个物品，价值为 6。 g[2][3] = {0, 2, 4, 6}。

i,j取不同的值，对应不同的 g[i][j]，也就是对应不同的集合。 **f[i][j]是个一个数**，是g[i][j]这个集合中的最大值。

例如：f[2][3]表示从前两种物品中进行选择，且总体积不大于三的获得的最大价值。
**f[2][3]=max(g[2][3])=6**

因此，只需要求出各个集合的最大值就能找到答案。

#### 2. 状态计算（求某个集合的最大值）
将g[i][j]拆分成互斥的A B两部分。
  * A:不包含第i件物品。
  * B:包含第i件物品。
**为什么要分成两部分**
  * 每件物品都有两种可能性：选择放入背包或不放入背包。
  * 不选择第i件物品：说明背包的最大价值和第i-1件物品相关，并且背包的容量保持不变。此时的状态可以表示为f[i-1][j]，即考虑前i-1件物品，在背包容量为j的情况下可以获得的最大价值。
  * 选择第i件物品：意味着我们需要从背包中减去第i件物品的重量，然后加上它的价值。这时的状态可以表示为f[i-1][j-w[i]]+v[i],w[i]表示第i件物品的重量，v[i]是其价值。这个表达式意味着在考虑前i-1件物品的基础上，如果还有足够的空间来装下第i件物品，那么就将它加入背包，并计算新的最大价值。
#### 3. 确定初始值
01背包问题的有些状态是能直接确认的。
例如f[0][0]。
f[0][0]=0,f[1][0]=0,f[2][0]=0,f[n][0]=0.
因此i从1遍历到N，j从1遍历到V，就能求出所有的f[i][j]。
### 代码详情
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
      if(V[i]<=j){
          f[i][j]=max(f[i-1][j],f[i-1][j-V[i]]+W[i]);
      }
      else{
         f[i][j]=f[i-1][j];
      }
    }
}
```
#### 代码解释
* ```for(int i=1;i<=n;i++)```：遍历每一件物品
* ```for(int j=1;j<=m;j++)```：遍历每种体积大小
   * 倒序的原因：在进行第i轮时，```f[j]=max(f[j],f[j-v[i]]+w[i])```，此时的```f[j-v[i]]```已经经过第i轮的更新了。例如：第i件物品的体积为3，背包的容量为7，那么```f[7=max(f[7,f[4]+w[i])```，此时的f[4]已经经过第i轮的更新了，因此f[4]可能包含物品i，再算是重复的了。但是如果是倒序，此时的f[4]为i-1轮的值，因此倒序是正确的。
* ```if(V[i]<=j)```
    * 将```V[i]```与```j```比较的原因：这个条件是判断是否放入第i件物品，如果成立，即```V[i]<=j```一定成立，因此一定可以放入第i件物品。
* ```f[i][j]=max(f[i-1][j],f[i-1][j-V[i]]+W[i])```：即上述条件成立，比较```f[i-1][j]```和```f[i-1][j-V[i]]+W[i]```：
  * ```f[i][j]=f[i-1][j]```：代表不选这个物品，因为在相同体积下，不选这个物品的价值更大。
  * ```f[i][j]=f[i-1][j-V[i]]+W[i]```：代表选这个物品，因为如果选上这个物品后，价值变大了。
* ```f[i][j]=f[i-1][j]```：即上述条件不成立，因此在相同体积下，选择不放该物品即f[i-1][j]。
#### 优化版本
```cpp
for(int i = 1; i <= n; i++) {
  int v, w;
  cin >> v >> w;      // 边输入边处理
  for(int j = m; j >= v; j--)
    f[j] = max(f[j], f[j - v] + w);
}
```
```cpp
for(int i = 1; i <= n; i++) 
    for(int j = m; j >= 0; j--)
    {
        if(j < v[i]) 
            f[i][j] = f[i - 1][j];  // 优化前
            f[j] = f[j];            // 优化后，该行自动成立，可省略。
        else    
            f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);  // 优化前
            f[j] = max(f[j], f[j - v[i]] + w[i]);                   // 优化后
    }
```
```cpp
for(int i = 1; i <= n; i++)
{
    for(int j = m; j >= v[i]; j--)  
        f[j] = max(f[j], f[j - v[i]] + w[i]);
} 
```
## 完全背包问题
### 暴力代码
```cpp
for(int i=1;i<=n;i++){
  for(int j=0;j<=m;j++){
    for(int k=0;k*v[i]<=j;k++){
      f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
    }
  }
}
```
### 初级优化
## 多重背包问题
### 优化版本
```cpp
/* 将多重背包问题进行二进制优化 至于为什么不能像完全背包一样利用f[i,j]和f[i,j-v]状态方程优化，
   因为f[i,j]比f[i,j-v]多了一项，优化不掉，不懂的话看底部提供的题解 ，所以本题我们使用二进制优化 */
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 11010, M = 2010; //这里N开的数据范围的依据:多重背包问题中的一个「箱子」相当于01背包问题中的一件「物品」，实际上我们是要将s[i]用几个箱子装进去，因此我们需要估计出多重背包问题中到底有多少个箱子。
                               //这里的箱子也就是二进制优化下的s[i] 由题 s[i]<=2000 则log2000 < 11(log以2为底) 一共最多1000件物品，则我们需要开的范围就是 11*1000+10=11010
int v[N], w[N];
int f[M]; //f[]是装不同背包容积下的物品最大价值，所以用背包容积来开f[]数组

int main()
{
    int n,m;
    scanf("%d%d", &n, &m);
    int cnt = 0; //重新定义存储物品的编号

    for (int i = 1; i <= n; i ++ )
    {
        int a, b, s;
        scanf("%d%d%d", &a, &b, &s); //依次录入i号物品的体积 价值 数量
        int k = 1; //定义箱子可以放物品的初始值 第一个箱子可以放一个i号物品

        while (k <= s)
        {
            cnt ++ ; //编号增加 可以看成是每一个箱子的编号
            v[cnt] = a * k; //这个箱子可以存的i号物品总体积  箱子可以放的物品总数 * 物品体积 = 物品总体积
            w[cnt] = b * k; //这个箱子可以存的i号物品总价值
            s -= k; //从i号物品总个数中减去这个箱子装的k个 方便while循环条件判断
            k *= 2; //二进制优化 下一个箱子可以放的物品数量是上一个的两倍
        }
        if (s > 0) //如果物品i还没有被二进制箱子存完 再开一个可以存还剩下的所有物品i的箱子
        {
            cnt ++ ; //当前箱子的编号
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    n = cnt; //关键一步！将物品编号更改为所有物品在箱子里装完后箱子的编号

    //上面结束后 我们将物品全部装进了箱子 我们不管想在背包里装多少个物品i，都可以装箱子的方式实现 
    //例如要装7个物品i 我们就用物品i的1号2号3号箱子(1号能装1个i 2号能装2个i 3号能装4个i) 
    //这就是我们使用二进制优化的意义，能将所有需要的物品数量表示出来
    //由于所有需要的物品数量都能用不同箱子的组合表达 所以现在每个箱子的状态只能是 用或者不用 从而转化为01背包问题

    //对照01背包代码
    for (int i = 1; i <= n; i ++ ) //注意n已经被cnt重新赋值了
        for (int j = m; j >= v[i]; j -- ) //01背包逆序存储
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    printf("%d\n", f[m]);

    return 0;
}
//https://www.acwing.com/solution/content/20115/
//https://blog.csdn.net/raelum/article/details/128996521
```