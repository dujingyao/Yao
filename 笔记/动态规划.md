# 背包问题
## 01背包问题
每个物品只能被选择一次，找到一种选择方案，在背包能装下的情况下，使得选择物品的总价值最大，然后输出总价值。
### 解决步骤
#### 1. 集合及集合状态
   
**集合，是一些方案的集合。**

用 g[i][j] 表示从前 i 种物品中进行选择，且总体积不大于 j 的各个选法获得的价值的集合。注意， **g[i][j] 是个集合**，表示一堆数：所有可能选出的价值。

例如 g[2][3] 从前 2 种物品中进行选择，且总体积不大于 3 的各个选法获得的价值的集合。选择方案有三种：都不选，价值为 0、选择第 1 个物品，价值为 2、选择第 2 个物品，价值为 4、选择第 1，第 2 个物品，价值为 6。 g[2][3] = {0, 2, 4, 6}。

i,j取不同的值，对应不同的 g[i][j]，也就是对应不同的集合。 **f[i][j]是个一个数**，是g[i][j]这个集合中的最大值。

例如：f[2][3]表示从前两种物品中进行选择，且总体积不大于三的获得的最大价值。
**f[2][3]=max(g[2][3])=6**

因此，只需要求出各个集合的最大值就能找到答案。

#### 2. 状态计算（求某个集合的最大值）
将g[i][j]拆分成互斥的A B两部分。
  * A:不包含第i件物品。
  * B:包含第i件物品。
**为什么要分成两部分**
  * 每件物品都有两种可能性：选择放入背包或不放入背包。
  * 不选择第i件物品：说明背包的最大价值和第i-1件物品相关，并且背包的容量保持不变。此时的状态可以表示为f[i-1][j]，即考虑前i-1件物品，在背包容量为j的情况下可以获得的最大价值。
  * 选择第i件物品：意味着我们需要从背包中减去第i件物品的重量，然后加上它的价值。这时的状态可以表示为f[i-1][j-w[i]]+v[i],w[i]表示第i件物品的重量，v[i]是其价值。这个表达式意味着在考虑前i-1件物品的基础上，如果还有足够的空间来装下第i件物品，那么就将它加入背包，并计算新的最大价值。
#### 3. 确定初始值
01背包问题的有些状态是能直接确认的。
例如f[0][0]。
f[0][0]=0,f[1][0]=0,f[2][0]=0,f[n][0]=0.
因此i从1遍历到N，j从1遍历到V，就能求出所有的f[i][j]。
### 代码详情
```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
      if(V[i]<=j){
          f[i][j]=max(f[i-1][j],f[i-1][j-V[i]]+W[i]);
      }
      else{
         f[i][j]=f[i-1][j];
      }
    }
}
```
#### 代码解释
* ```for(int i=1;i<=n;i++)```：遍历每一件物品
* ```for(int j=1;j<=m;j++)```：遍历每种体积大小
* ```if(V[i]<=j)```
    * 将```V[i]```与```j```比较的原因：这个条件是判断是否放入第i件物品，如果成立，即```V[i]<=j```一定成立，因此一定可以放入第i件物品。
* ```f[i][j]=max(f[i-1][j],f[i-1][j-V[i]]+W[i])```：即上述条件成立，比较```f[i-1][j]```和```f[i-1][j-V[i]]+W[i]```：
  * ```f[i][j]=f[i-1][j]```：代表不选这个物品，因为在相同体积下，不选这个物品的价值更大。
  * ```f[i][j]=f[i-1][j-V[i]]+W[i]```：代表选这个物品，因为如果选上这个物品后，价值变大了。
* ```f[i][j]=f[i-1][j]```：即上述条件不成立，因此在相同体积下，选择不放该物品即f[i-1][j]。
#### 优化版本
```cpp
for(int i = 1; i <= n; i++) {
  int v, w;
  cin >> v >> w;      // 边输入边处理
  for(int j = m; j >= v; j--)
    f[j] = max(f[j], f[j - v] + w);
}
```